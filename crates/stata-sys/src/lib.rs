#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[inline]
pub unsafe fn SV_MISSVAL() -> f64 {
    if _stata_.is_null() {
        panic!("Stata missval not available");
    }
    
    (*_stata_).missval
}
// Include the bindings generated by bindgen
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

// Explicitly define the SF_ functions
// These match the macros in stplugin.h and make them available as Rust functions

// Data access functions
#[inline]
pub unsafe fn SF_vdata(i: i32, j: i32, d: *mut f64) -> i32 {
    if let Some(func) = (*_stata_).vdata {
        (func)(i, j, d)
    } else {
        panic!("safevdata function is not available")
    }
}


// Dataset information functions
#[inline]
pub unsafe fn SF_nobs() -> i32 {
    if let Some(func) = (*_stata_).nobs {
        (func)()
    } else {
        panic!("nobs function is not available")
    }
}


#[inline]
pub unsafe fn SF_nvar() -> i32 {
    if let Some(func) = (*_stata_).nvar {
        (func)()
    } else {
        panic!("nvar function is not available")
    }
}

// Display and error reporting


#[inline]
pub unsafe fn SF_error(s: *mut std::os::raw::c_char) -> i32 {
    if let Some(func) = (*_stata_).spouterr {
        (func)(s)
    } else {
        panic!("spouterr function is not available")
    }
}

// Missing value functions
#[inline]
pub unsafe fn SF_is_missing(z: f64) -> bool {
    if let Some(func) = (*_stata_).ismissing {
        let result = (func)(z);
        result != 0
    } else {
        panic!("ismissing function is not available")
    }
}

// Variable lookup/information
#[inline]
pub unsafe fn SF_var_is_string(i: i32) -> bool {
    if let Some(func) = (*_stata_).isstr {
        let result = (func)(i);
        result != 0
    } else {
        panic!("isstr function is not available")
    }
}

#[inline]
pub unsafe fn SF_stfindvar(s: *mut std::os::raw::c_char, len: i32) -> i32 {
    if let Some(func) = (*_stata_).stfindvar {
        (func)(s, len)
    } else {
        panic!("stfindvar function is not available")
    }
}

// String data functions
#[inline]
pub unsafe fn SF_sdata(i: i32, j: i32, s: *mut std::os::raw::c_char) -> i32 {
    if let Some(func) = (*_stata_).sdata {
        (func)(i, j, s)
    } else {
        panic!("sdata function is not available")
    }
}

#[inline]
pub fn display(
    message:&str
) -> i32 {
    let message_c = std::ffi::CString::new(format!("{}\n", message)).unwrap();
    
    unsafe {
        SF_display(message_c.as_ptr()  as *mut std::os::raw::c_char)
    }
}

#[inline]
pub fn set_macro(
    macro_name:&str,
    value:&str,
    global:bool
) -> i32 {

    let macro_name_c = if global {
        std::ffi::CString::new(macro_name)
    } else {
        std::ffi::CString::new(format!("_{}",macro_name))
    }.unwrap();

    let value_c = std::ffi::CString::new(value).unwrap();

    unsafe {
        SF_macro_save(
            macro_name_c.as_ptr() as *mut std::os::raw::c_char, 
            value_c.as_ptr() as *mut std::os::raw::c_char
        )
    }
}


pub fn get_macro(macro_name: &str, global: bool, buffer_size: Option<usize>) -> Result<String, &'static str> {
    // Format the macro name with underscore prefix if not global
    let macro_name_c = if global {
        std::ffi::CString::new(macro_name)
    } else {
        std::ffi::CString::new(format!("_{}", macro_name))
    }.unwrap();
    
    // Use provided buffer size or default to a reasonable size
    let buf_size = buffer_size.unwrap_or(1024);
    let mut buffer = vec![0i8; buf_size];
    
    let result = unsafe {
        SF_macro_use(
            macro_name_c.as_ptr() as *mut std::os::raw::c_char,
            buffer.as_mut_ptr(),
            buf_size as i32
        )
    };
    
    if result > 0 {
        // Error occurred
        return Err("Macro not found or other error");
    }
    
    // Convert the C string buffer to a Rust String
    let c_str = unsafe { std::ffi::CStr::from_ptr(buffer.as_ptr()) };
    match c_str.to_str() {
        Ok(s) => Ok(s.to_string()),
        Err(_) => Err("Invalid UTF-8 in macro value")
    }
}

#[inline]
pub fn set_scalar(
    scalar_name:&str,
    value:&f64,
    //  global:bool
) -> i32 {

    let scalar_name_c = std::ffi::CString::new(scalar_name).unwrap();


    unsafe {
        SF_scal_save(
            scalar_name_c.as_ptr() as *mut std::os::raw::c_char, 
            value.clone()
        )
    }
}




#[inline]
pub unsafe fn SF_macro_use(
    m: *mut std::os::raw::c_char,
    contents: *mut std::os::raw::c_char,
    len: i32
) -> i32 {
    if let Some(func) = (*_stata_).macuse {
        (func)(m,contents,len)
    } else {
        panic!("macuse function is not available")
    }
}   


#[inline]
pub fn replace_number(
    value:Option<f64>,
    row:usize,
    column:usize
) -> i32 {
    match value {
        Some(val) => unsafe {
            SF_vstore(
                column as i32,
                row as i32,
                val
            )
        },
        //  Do nothing
        None => 0
    }
}


#[inline]
pub fn replace_string(
    value:Option<String>,
    row:usize,
    column:usize
) -> i32 {
    match value {
        Some(val) => unsafe {
            SF_sstore(
                column as i32,
                row as i32,
                std::ffi::CString::new(val).unwrap().as_ptr().cast_mut()
            )
        },
        //  Do nothing
        None => 0
    }
}

//  Internal wrappers
#[inline]
unsafe fn SF_macro_save(m: *mut std::os::raw::c_char, t:*mut std::os::raw::c_char) -> i32 {
    if let Some(func) = (*_stata_).macresave {
        (func)(m, t)
    } else {
        panic!("macro save function is not available")
    }
}


#[inline]
unsafe fn SF_scal_save(s: *mut std::os::raw::c_char, d:f64) -> i32 {
    if let Some(func) = (*_stata_).scalsave {
        (func)(s, d)
    } else {
        panic!("scalar save function is not available")
    }
}

#[inline]
unsafe fn SF_display(s: *mut std::os::raw::c_char) -> i32 {
    if let Some(func) = (*_stata_).spoutsml {
        (func)(s)
    } else {
        panic!("spoutsml function is not available")
    }
}


#[inline]
unsafe fn SF_vstore(i: i32, j: i32, v: f64) -> i32 {
    //  if let Some(func) = (*_stata_).safestore {
        if let Some(func) = (*_stata_).store {
        (func)(i, j, v)
    } else {
        panic!("safestore function is not available")
    }
}

#[inline]
unsafe fn SF_sstore(i: i32, j: i32, s: *mut std::os::raw::c_char) -> i32 {
    if let Some(func) = (*_stata_).sstore {
        (func)(i, j, s)
    } else {
        panic!("sstore function is not available")
    }
}
